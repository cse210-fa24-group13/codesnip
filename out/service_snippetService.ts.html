<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>service/snippetService.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#activate">activate</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">service/snippetService.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { DataAccess } from "../data/dataAccess";
import { FileDataAccess } from "../data/fileDataAccess";
import { Snippet } from "../interface/snippet";

export class SnippetService {
    private _rootSnippet: Snippet;

    constructor(private _dataAccess: DataAccess) {
        this._rootSnippet = this.loadSnippets();
    }

    // static utility methods

    static findParent(parentId: number, currentElt: Snippet): Snippet | undefined {
        var i, currentChild, result;

        if (parentId === currentElt.id) {
            return currentElt;
        } else {
            // Use a for loop instead of forEach to avoid nested functions
            // Otherwise "return" will not work properly
            for (i = 0; i &lt; currentElt.children.length; i++) {
                currentChild = currentElt.children[i];

                // Search in the current child
                result = this.findParent(parentId, currentChild);

                // Return the result if the node has been found
                if (result !== undefined) {
                    return result;
                }
            }
            // The node has not been found and we have no more options
            return undefined;
        }
    }

   /**
   * to be used like the following:
   * let result: any[] = [];
   * Snippet.flatten(snippetsProvider.snippets.children, result);
   * @param arr array of element
   * @param result final result
   */
    private static flatten(arr: any, result: any[] = []) {
        for (let i = 0, length = arr.length; i &lt; length; i++) {
            const value = arr[i];
            if (value.folder === true) {
                SnippetService.flatten(value.children, result);
            } else {
                result.push(value);
            }
        }
        return result;
    }
    
    public static flattenAndKeepFolders(arr: any, result: any[] = []) {
        for (let i = 0, length = arr.length; i &lt; length; i++) {
            const value = arr[i];
            if (value.folder === true) {
                result.push(value);
                SnippetService.flattenAndKeepFolders(value.children, result);
            } else {
                result.push(value);
            }
        }
        return result;
    }

    // private methods

    private _reorderArray(arr: Snippet[], oldIndex: number, newIndex: number) {
        if (newIndex &lt; arr.length) {
            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
        }
    }

    private _sortArray(arr: Snippet[]) {
        arr.sort((a, b) => a.label.localeCompare(b.label));
    }

    private _sortSnippetsAndChildren(snippets: Snippet[]) {
        this._sortArray(snippets);
        snippets.forEach((s) => {
            if (s.folder &amp;&amp; s.children.length > 0) {
                this._sortSnippetsAndChildren(s.children);
            }
        });
    }

    private _updateLastId(newId: number): void {
        this._rootSnippet.lastId = newId;
    }
    
    // public service methods

    refresh(): void {
        this._rootSnippet = this.loadSnippets();
    }

    loadSnippets(): Snippet {
        return this._dataAccess.load();
    }
    
    saveSnippets(): void {
        this._dataAccess.save(this._rootSnippet);
    }

    fixLastId(): void{
        let snippetIds = this.getAllSnippetsAndFolders().map(s=>s.id);
        const maxId = Math.max.apply(Math, snippetIds);
        if (this._rootSnippet.lastId &amp;&amp; this._rootSnippet.lastId &lt; maxId) {
            this._updateLastId(maxId);
        }
    }

    getRootChildren(): Snippet[] {
        return this._rootSnippet.children;
    }

    getAllSnippets(): Snippet[] {
        // sync snippets
        this._rootSnippet = this.loadSnippets();
        let snippets: Snippet[] = [];
        SnippetService.flatten(this._rootSnippet.children, snippets);
        return snippets;
    }

    getAllSnippetsAndFolders(): Snippet[] {
        // sync snippets
        this._rootSnippet = this.loadSnippets();
        let snippets: Snippet[] = [];
        SnippetService.flattenAndKeepFolders(this._rootSnippet.children, snippets);
        return snippets;
    }

    incrementLastId(): number {
        return (this._rootSnippet.lastId ?? 0) + 1;
    }

    getParent(parentId: number | undefined): Snippet | undefined {
        return SnippetService.findParent(parentId ?? Snippet.rootParentId, this._rootSnippet);
    }

    compact(): string {
        return JSON.stringify(this._rootSnippet);
    }

    // snippet management services

    addSnippet(newSnippet: Snippet): void {
        this.addExistingSnippet(newSnippet);
        this._updateLastId(newSnippet.id);
    }

    addExistingSnippet(newSnippet: Snippet): void {
        newSnippet.parentId === Snippet.rootParentId
            ? this._rootSnippet.children.push(newSnippet)
            : SnippetService.findParent(newSnippet.parentId ?? Snippet.rootParentId, this._rootSnippet)?.children.push(newSnippet);
    }

    updateSnippet(snippet: Snippet): void {
        const parentElement = SnippetService.findParent(snippet.parentId ?? Snippet.rootParentId, this._rootSnippet);

        if (parentElement) {
            const index = parentElement.children.findIndex((obj => obj.id === snippet.id));

            if (index > -1) {
                parentElement.children.map(obj =>
                    obj.id === snippet.id ? {
                        ...obj,
                        label: snippet.label,
                        // if its a folder, don't update content, use old value instead
                        // if its a snippet, update its content
                        value: [snippet.folder ? obj.value : snippet.value]
                    }
                        : obj
                );
            }
        }
    }

    overrideSnippetId(snippet: Snippet): void {
        let lastId = this.incrementLastId();
        snippet.id = lastId;
        this.updateSnippet(snippet);
        this._updateLastId(snippet.id);
    }

    removeSnippet(snippet: Snippet): void {
        const parentElement = SnippetService.findParent(snippet.parentId ?? Snippet.rootParentId, this._rootSnippet);

        if (parentElement) {
            const index = parentElement.children.findIndex((obj => obj.id === snippet.id));

            if (index > -1) {
                parentElement?.children.splice(index, 1);
            }
        }
    }

    moveSnippet(snippet: Snippet, offset: number) {
        const parentElement = SnippetService.findParent(snippet.parentId ?? Snippet.rootParentId, this._rootSnippet);

        if (parentElement) {
            const index = parentElement.children.findIndex((obj => obj.id === snippet.id));

            if (index > -1 &amp;&amp; parentElement.children) {
                this._reorderArray(parentElement.children, index, index + offset);
            }
        }
    }

    sortSnippets(snippet: Snippet) {
        if (snippet.folder &amp;&amp; snippet.children.length > 0) {
            this._sortArray(snippet.children);
        }
    }

    sortAllSnippets() {
        let snippet = this._rootSnippet;
        if (snippet.children.length > 0) {
            this._sortSnippetsAndChildren(snippet.children);
        }
    }

    exportSnippets(destinationPath: string, parentId: number) {
        const parentElement = SnippetService.findParent(parentId ?? Snippet.rootParentId, this._rootSnippet);
        if (parentElement) {
            // save file using destroyable instance of FileDataAccess
            new FileDataAccess(destinationPath).save(parentElement);
        }
    }

    importSnippets(destinationPath: string) {
        // save a backup version of current snippets next to the file to import
        this.exportSnippets(
            destinationPath.replace(FileDataAccess.dataFileExt, `_pre-import-bak${FileDataAccess.dataFileExt}`),
            Snippet.rootParentId
        );
        let newSnippets: Snippet = new FileDataAccess(destinationPath).load();
        this._rootSnippet.children = newSnippets.children;
        this._rootSnippet.lastId = newSnippets.lastId;
    }
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Sun Nov 17 2024 00:33:02 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
